// Part 2 skeleton

	module fill
		(
			CLOCK_50,						//	On Board 50 MHz
			// Your inputs and outputs here
			KEY,							// On Board Keys
			// The ports below are for the VGA output.  Do not change.
			VGA_CLK,   						//	VGA Clock
			VGA_HS,							//	VGA H_SYNC
			VGA_VS,							//	VGA V_SYNC
			VGA_BLANK_N,						//	VGA BLANK
			VGA_SYNC_N,						//	VGA SYNC
			VGA_R,   						//	VGA Red[9:0]
			VGA_G,	 						//	VGA Green[9:0]
			VGA_B   						//	VGA Blue[9:0]
		);

		input			CLOCK_50;				//	50 MHz
		input	[3:0]	KEY;					
		// Declare your inputs and outputs here
		// Do not change the following outputs
		output			VGA_CLK;   				//	VGA Clock
		output			VGA_HS;					//	VGA H_SYNC
		output			VGA_VS;					//	VGA V_SYNC
		output			VGA_BLANK_N;				//	VGA BLANK
		output			VGA_SYNC_N;				//	VGA SYNC
		output	[7:0]	VGA_R;   				//	VGA Red[7:0] Changed from 10 to 8-bit DAC
		output	[7:0]	VGA_G;	 				//	VGA Green[7:0]
		output	[7:0]	VGA_B;   				//	VGA Blue[7:0]
		
		wire resetn;
		assign resetn = KEY[0];
		
		// Create the colour, x, y and writeEn wires that are inputs to the controller.

		wire [2:0] colour;
		wire [7:0] x;
		wire [6:0] y;
		wire writeEn;

		// Create an Instance of a VGA controller - there can be only one!
		// Define the number of colours as well as the initial background
		// image file (.MIF) for the controller.
		vga_adapter VGA(
								.resetn(resetn),
								.clock(CLOCK_50),
								.colour(1'b010),
								.x(7'b0011100),
								.y(6'b001100),
								.plot(writeEn),
								/* Signals for the DAC to drive the monitor. */
								.VGA_R(VGA_R),
								.VGA_G(VGA_G),
								.VGA_B(VGA_B),
								.VGA_HS(VGA_HS),
								.VGA_VS(VGA_VS),
								.VGA_BLANK(VGA_BLANK_N),
								.VGA_SYNC(VGA_SYNC_N),
								.VGA_CLK(VGA_CLK));
		defparam VGA.RESOLUTION = "160x120";
		defparam VGA.MONOCHROME = "FALSE";
		defparam VGA.BITS_PER_COLOUR_CHANNEL = 1;
		defparam VGA.BACKGROUND_IMAGE = "black.mif";
			
		// Put your code here. Your code should produce signals x,y,colour and writeEn
		// for the VGA controller, in addition to any other functionality your design may require.
	
	
endmodule
     
                
//
//module control(
//					input clk,
//					input resetn,
//					input go,
//					output reg  ld_x, ld_y,
//					);
//
//	reg [6:0] current_state, next_state; 
//    
//	localparam  S_LOAD_X        = 2'd0,
//					S_LOAD_X_WAIT   = 2'd1,
//					 S_LOAD_Y        = 2'd2,
//					 S_LOAD_Y_WAIT   = 2'd3,
//
//
//	 // Next state logic aka our state table
//    always@(*)
//    begin: state_table 
//            case (current_state)
//                S_LOAD_X: next_state = go ? S_LOAD_X_WAIT : S_LOAD_X; // Loop in current state until value is input
//                S_LOAD_X_WAIT: next_state = go ? S_LOAD_X_WAIT : S_LOAD_Y; // Loop in current state until go signal goes low
//                S_LOAD_Y: next_state = go ? S_LOAD_B_WAIT : S_LOAD_B; // Loop in current state until value is input
//                S_LOAD_Y_WAIT: next_state = go ? S_LOAD_B_WAIT : S_LOAD_X; // Loop in current state until go signal goes low
//            default:     next_state = S_LOAD_X;
//        endcase
//    end // state_table
//   
//
//    // Output logic aka all of our datapath control signals
//    always @(*)
//    begin: enable_signals
//        // By default make all our signals 0 to avoid latches.
//        // This is a different style from using a default statement.
//        // It makes the code easier to read.  If you add other out
//        // signals be sure to assign a default value for them here.
//
//        ld_x = 1'b0;
//        ld_Y = 1'b0;
//
//        case (current_state)
//            S_LOAD_X: begin
//                ld_x = 1'b1;
//                end
//            S_LOAD_Y: begin
//                ld_y = 1'b1;
//                end
//
//        // default:    // don't need default since we already made sure all of our outputs were assigned a value at the start of the always block
//        endcase
//    end // enable_signals
//   
//    // current_state registers
//    always@(posedge clk)
//    begin: state_FFs
//        if(!resetn)
//            current_state <= S_LOAD_X;
//        else
//            current_state <= next_state;
//    end // state_FFS
//endmodule
//
//module datapath(
//    input clk,
//    input resetn,
//    input [7:0] data_in,
//    input ld_alu_out, 
//    input ld_x, ld_y,
//    input ld_r,
//    input alu_op, 
//    input [1:0] alu_select_a, alu_select_b,
//    output reg [7:0] data_result
//    );
//    
//    // input registers
//    reg [7:0] a, b, c, x;
//
//    // output of the alu
//    reg [7:0] alu_out;
//    // alu input muxes
//    reg [7:0] alu_a, alu_b;
//    
//    // Registers a, b, c, x with respective input logic
//    always@(posedge clk) begin
//        if(!resetn) begin
//            a <= 8'b0; 
//            b <= 8'b0; 
//            c <= 8'b0; 
//            x <= 8'b0; 
//        end
//        else begin
//            if(ld_a)
//                a <= ld_alu_out ? alu_out : data_in; // load alu_out if load_alu_out signal is high, otherwise load from data_in
//            if(ld_b)
//                b <= ld_alu_out ? alu_out : data_in; // load alu_out if load_alu_out signal is high, otherwise load from data_in
//            if(ld_x)
//                x <= data_in;
//            if(ld_c)
//                c <= data_in;
//        end
//    end
// 
//    // Output result register
//    always@(posedge clk) begin
//        if(!resetn) begin
//            data_result <= 8'b0; 
//        end
//        else 
//            if(ld_r)
//                data_result <= alu_out;
//    end
//
//    // The ALU input multiplexers
//    always @(*)
//    begin
//        case (alu_select_a)
//            2'd0:
//                alu_a = a;
//            2'd1:
//                alu_a = b;
//            2'd2:
//                alu_a = c;
//            2'd3:
//                alu_a = x;
//            default: alu_a = 8'b0;
//        endcase
//
//        case (alu_select_b)
//            2'd0:
//                alu_b = a;
//            2'd1:
//                alu_b = b;
//            2'd2:
//                alu_b = c;
//            2'd3:
//                alu_b = x;
//            default: alu_b = 8'b0;
//        endcase
//    end
//
//    // The ALU 
//    always @(*)
//    begin : ALU
//        // alu
//        case (alu_op)
//            0: begin
//                   alu_out = alu_a + alu_b; //performs addition
//               end
//            1: begin
//                   alu_out = alu_a * alu_b; //performs multiplication
//               end
//            default: alu_out = 8'b0;
//        endcase
//    end
//    
//endmodule
